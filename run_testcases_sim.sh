#!/usr/bin/env bash
set -euo pipefail

# Batch test runner for Ascend310B simulator (CA/PV).
#
# Testcase layout (default: ./testcases/<case_name>/):
#   - v1.bin            int32 little-endian, shape [32,32] (1024 elems)
#   - v2_init.bin       (optional) same format; if missing, init with -1
#   - expect_v2.bin     (optional) same format; if missing, generated by CPU sim
#
# Usage:
#   bash run_testcases_sim.sh [ca|pv] [testcases_dir]
#
# Env:
#   SOC=Ascend310B1     target SoC
#   DEVICE_ID=0         simulator device id
#   CANN=/path/to/cann   override CANN install root
#   KERNEL_SYM=...       override kernel entry symbol
#   KERNEL_RE=...        regex to detect kernel symbol (default: ^vec_add_scalar_kernel_2d)

MODE="${1:-ca}" # ca (camodel) or pv (pvmodel)
TESTDIR="${2:-testcases}"

SOC="${SOC:-Ascend310B1}"
DEVICE_ID="${DEVICE_ID:-0}"
KERNEL_RE="${KERNEL_RE:-^vec_add_scalar_kernel_2d}"

if [[ -z "${CANN:-}" ]]; then
  if [[ -n "${ASCEND_HOME_PATH:-}" ]]; then
    CANN="$ASCEND_HOME_PATH"
  else
    CANN="$HOME/miniconda3/envs/cann850/Ascend/cann-8.5.0"
  fi
fi

SIM_HOME="$CANN/x86_64-linux/simulator"

if [[ ! -f "$CANN/set_env.sh" ]]; then
  echo "ERROR: cannot find $CANN/set_env.sh" >&2
  exit 2
fi

source "$CANN/set_env.sh"

if [[ "$MODE" != "ca" && "$MODE" != "pv" ]]; then
  echo "Usage: bash run_testcases_sim.sh [ca|pv] [testcases_dir]" >&2
  exit 2
fi

if [[ ! -d "$TESTDIR" ]]; then
  echo "ERROR: testcase dir not found: $TESTDIR" >&2
  exit 2
fi

mkdir -p .tmp

export ASCEND_PROCESS_LOG_PATH="$PWD/.tmp/ascend_log"
export CAMODEL_LOG_PATH="$PWD/.tmp/camodel_dump"
mkdir -p "$ASCEND_PROCESS_LOG_PATH" "$CAMODEL_LOG_PATH"

# ACL loads libruntime.so; on simulator we bridge it to libruntime_camodel.so / libruntime_cmodel.so.
mkdir -p .tmp/simlib
if [[ "$MODE" == "ca" ]]; then
  ln -sf "$SIM_HOME/$SOC/lib/libruntime_camodel.so" .tmp/simlib/libruntime.so
else
  ln -sf "$SIM_HOME/$SOC/lib/libruntime_cmodel.so" .tmp/simlib/libruntime.so
fi

if [[ ! -d "$SIM_HOME/$SOC" ]]; then
  echo "ERROR: simulator soc not found: $SIM_HOME/$SOC" >&2
  echo "       try: export SOC=Ascend310B1 (or another SoC under $SIM_HOME)" >&2
  exit 2
fi
if [[ ! -f "$SIM_HOME/$SOC/lib/libruntime_camodel.so" || ! -f "$SIM_HOME/$SOC/lib/libruntime_cmodel.so" ]]; then
  echo "ERROR: simulator runtime libs not found under: $SIM_HOME/$SOC/lib" >&2
  exit 2
fi

export LD_LIBRARY_PATH="$PWD/.tmp/simlib:$SIM_HOME/$SOC/lib:$SIM_HOME/common/data:$CANN/lib64:${LD_LIBRARY_PATH:-}"

INC1="$CANN/include"
INC2="$CANN/include/pto"
LIB="$CANN/lib64"

DEV_O=".tmp/kernel_${SOC}.o"

echo "[1/5] Build device binary for $SOC ($MODE)"
ccec -c -O2 -std=c++17 kernel.cpp \
  -I. -I"$INC1" -I"$INC2" \
  --cce-aicore-arch=cce-aicore-only --cce-aicore-only \
  --cce-soc-version="$SOC" --cce-soc-core-type=AiCore \
  --cce-enable-pto-passes \
  -o "$DEV_O"

echo "[2/5] Detect kernel entry symbol"
KERNEL_SYM="${KERNEL_SYM:-}"
if [[ -z "$KERNEL_SYM" ]]; then
  KERNEL_SYM="$(llvm-objdump -t "$DEV_O" | awk '{print $NF}' | grep -E "$KERNEL_RE" | head -n 1)"
fi
if [[ -z "$KERNEL_SYM" ]]; then
  echo "ERROR: cannot detect kernel symbol via regex: $KERNEL_RE" >&2
  echo "       set KERNEL_SYM=... to override" >&2
  exit 3
fi
echo "      kernel symbol: $KERNEL_SYM"

echo "[3/5] Generate & build runners"

cat > .tmp/runner_cpu.cpp <<'CPP'
#include <cstdint>
#include <cstdio>
#include <cstdlib>
#include <fstream>
#include <string>
#include <vector>

void vec_add_scalar_kernel_2d(int32_t* v1, int32_t* v2);

static std::vector<int32_t> ReadI32File(const std::string& path, size_t expect_elems) {
  std::ifstream ifs(path, std::ios::binary);
  if (!ifs) {
    std::fprintf(stderr, "ERROR: cannot open %s\n", path.c_str());
    std::exit(2);
  }
  ifs.seekg(0, std::ios::end);
  const std::streamoff bytes = ifs.tellg();
  ifs.seekg(0, std::ios::beg);
  if (bytes != static_cast<std::streamoff>(expect_elems * sizeof(int32_t))) {
    std::fprintf(stderr, "ERROR: bad file size %s: got=%lld expect=%zu\n", path.c_str(),
                 static_cast<long long>(bytes), expect_elems * sizeof(int32_t));
    std::exit(2);
  }
  std::vector<int32_t> data(expect_elems);
  if (!ifs.read(reinterpret_cast<char*>(data.data()), bytes)) {
    std::fprintf(stderr, "ERROR: read failed: %s\n", path.c_str());
    std::exit(2);
  }
  return data;
}

static void WriteI32File(const std::string& path, const int32_t* data, size_t elems) {
  std::ofstream ofs(path, std::ios::binary);
  if (!ofs) {
    std::fprintf(stderr, "ERROR: cannot write %s\n", path.c_str());
    std::exit(2);
  }
  ofs.write(reinterpret_cast<const char*>(data), static_cast<std::streamsize>(elems * sizeof(int32_t)));
  if (!ofs) {
    std::fprintf(stderr, "ERROR: write failed: %s\n", path.c_str());
    std::exit(2);
  }
}

int main(int argc, char** argv) {
  if (argc < 3) {
    std::fprintf(stderr, "Usage: %s <v1.bin> <v2_init.bin|-> <out.bin>\n", argv[0]);
    return 2;
  }

  const std::string v1Path = argv[1];
  const std::string v2InitPath = argv[2];
  const std::string outPath = (argc > 3) ? argv[3] : "out_cpu.bin";

  constexpr size_t kRows = 32;
  constexpr size_t kCols = 32;
  constexpr size_t kNumel = kRows * kCols;

  std::vector<int32_t> v1 = ReadI32File(v1Path, kNumel);
  std::vector<int32_t> v2;
  if (v2InitPath == "-") {
    v2.assign(kNumel, -1);
  } else {
    v2 = ReadI32File(v2InitPath, kNumel);
  }

  vec_add_scalar_kernel_2d(v1.data(), v2.data());
  WriteI32File(outPath, v2.data(), kNumel);
  return 0;
}
CPP

cat > .tmp/runner_acl.cpp <<'CPP'
#include <acl/acl.h>

#include <cstdint>
#include <cstdio>
#include <cstdlib>
#include <fstream>
#include <string>
#include <vector>

static void CheckAcl(aclError err, const char* what) {
  if (err == ACL_SUCCESS) {
    return;
  }
  const char* recent = aclGetRecentErrMsg();
  if (recent == nullptr) {
    recent = "(null)";
  }
  std::fprintf(stderr, "%s failed, err=%d, recent=%s\n", what, static_cast<int>(err), recent);
  std::exit(1);
}

static std::vector<int32_t> ReadI32File(const std::string& path, size_t expect_elems) {
  std::ifstream ifs(path, std::ios::binary);
  if (!ifs) {
    std::fprintf(stderr, "ERROR: cannot open %s\n", path.c_str());
    std::exit(2);
  }
  ifs.seekg(0, std::ios::end);
  const std::streamoff bytes = ifs.tellg();
  ifs.seekg(0, std::ios::beg);
  if (bytes != static_cast<std::streamoff>(expect_elems * sizeof(int32_t))) {
    std::fprintf(stderr, "ERROR: bad file size %s: got=%lld expect=%zu\n", path.c_str(),
                 static_cast<long long>(bytes), expect_elems * sizeof(int32_t));
    std::exit(2);
  }
  std::vector<int32_t> data(expect_elems);
  if (!ifs.read(reinterpret_cast<char*>(data.data()), bytes)) {
    std::fprintf(stderr, "ERROR: read failed: %s\n", path.c_str());
    std::exit(2);
  }
  return data;
}

static void WriteI32File(const std::string& path, const int32_t* data, size_t elems) {
  std::ofstream ofs(path, std::ios::binary);
  if (!ofs) {
    std::fprintf(stderr, "ERROR: cannot write %s\n", path.c_str());
    std::exit(2);
  }
  ofs.write(reinterpret_cast<const char*>(data), static_cast<std::streamsize>(elems * sizeof(int32_t)));
  if (!ofs) {
    std::fprintf(stderr, "ERROR: write failed: %s\n", path.c_str());
    std::exit(2);
  }
}

struct KernelArgs {
  void* v1;
  void* v2;
};

int main(int argc, char** argv) {
  if (argc < 6) {
    std::fprintf(stderr,
                 "Usage: %s <kernel.o> <kernel_sym> <deviceId> <v1.bin> <v2_init.bin|-> <out.bin>\n",
                 argv[0]);
    return 2;
  }
  const char* binPath = argv[1];
  const char* kernelName = argv[2];
  const int deviceId = std::atoi(argv[3]);
  const std::string v1Path = argv[4];
  const std::string v2InitPath = argv[5];
  const std::string outPath = (argc > 6) ? argv[6] : "out_sim.bin";

  constexpr int kRows = 32;
  constexpr int kCols = 32;
  constexpr int kNumel = kRows * kCols;
  const size_t bytes = static_cast<size_t>(kNumel) * sizeof(int32_t);

  std::vector<int32_t> host_v1 = ReadI32File(v1Path, kNumel);
  std::vector<int32_t> host_v2;
  if (v2InitPath == "-") {
    host_v2.assign(kNumel, -1);
  } else {
    host_v2 = ReadI32File(v2InitPath, kNumel);
  }

  CheckAcl(aclInit(nullptr), "aclInit");
  CheckAcl(aclrtSetDevice(deviceId), "aclrtSetDevice");

  aclrtContext ctx = nullptr;
  CheckAcl(aclrtCreateContext(&ctx, deviceId), "aclrtCreateContext");

  aclrtStream stream = nullptr;
  CheckAcl(aclrtCreateStream(&stream), "aclrtCreateStream");

  void* dev_v1 = nullptr;
  void* dev_v2 = nullptr;
  CheckAcl(aclrtMalloc(&dev_v1, bytes, ACL_MEM_MALLOC_NORMAL_ONLY), "aclrtMalloc v1");
  CheckAcl(aclrtMalloc(&dev_v2, bytes, ACL_MEM_MALLOC_NORMAL_ONLY), "aclrtMalloc v2");

  CheckAcl(aclrtMemcpy(dev_v1, bytes, host_v1.data(), bytes, ACL_MEMCPY_HOST_TO_DEVICE), "H2D v1");
  CheckAcl(aclrtMemcpy(dev_v2, bytes, host_v2.data(), bytes, ACL_MEMCPY_HOST_TO_DEVICE), "H2D v2");

  aclrtBinaryLoadOptions opts;
  opts.options = nullptr;
  opts.numOpt = 0;

  aclrtBinHandle binHandle = nullptr;
  CheckAcl(aclrtBinaryLoadFromFile(binPath, &opts, &binHandle), "aclrtBinaryLoadFromFile");

  aclrtFuncHandle funcHandle = nullptr;
  CheckAcl(aclrtBinaryGetFunction(binHandle, kernelName, &funcHandle), "aclrtBinaryGetFunction");

  KernelArgs args{dev_v1, dev_v2};
  CheckAcl(aclrtLaunchKernel(funcHandle, 1, &args, sizeof(args), stream), "aclrtLaunchKernel");
  CheckAcl(aclrtSynchronizeStream(stream), "aclrtSynchronizeStream");

  CheckAcl(aclrtMemcpy(host_v2.data(), bytes, dev_v2, bytes, ACL_MEMCPY_DEVICE_TO_HOST), "D2H v2");
  WriteI32File(outPath, host_v2.data(), kNumel);

  (void)aclrtBinaryUnLoad(binHandle);
  (void)aclrtFree(dev_v2);
  (void)aclrtFree(dev_v1);
  (void)aclrtDestroyStream(stream);
  (void)aclrtDestroyContext(ctx);
  (void)aclrtResetDevice(deviceId);
  (void)aclFinalize();
  return 0;
}
CPP

TMPDIR="$PWD/.tmp" g++ -O2 -std=gnu++17 .tmp/runner_acl.cpp \
  -I"$INC1" \
  -L"$LIB" -lascendcl -lpthread -ldl \
  -o .tmp/run_310b_case

TMPDIR="$PWD/.tmp" g++ -O2 -std=gnu++17 -pthread \
  -D__CPU_SIM \
  -I. -I"$INC1" -I"$INC2" \
  -include pto/common/cpu_stub.hpp \
  kernel.cpp .tmp/runner_cpu.cpp \
  -o .tmp/run_cpu_case

diff_i32() {
  local expect="$1"
  local got="$2"
  python3 - "$expect" "$got" <<'PY'
import struct
import sys

def read_i32(path: str):
  with open(path, 'rb') as f:
    data = f.read()
  if len(data) % 4 != 0:
    raise SystemExit(f"bad size: {path} bytes={len(data)}")
  n = len(data) // 4
  return struct.unpack('<' + 'i'*n, data)

exp = read_i32(sys.argv[1])
got = read_i32(sys.argv[2])
if len(exp) != len(got):
  print(f"len mismatch: expect={len(exp)} got={len(got)}")
  sys.exit(1)
for i, (a, b) in enumerate(zip(exp, got)):
  if a != b:
    print(f"mismatch at {i}: got={b} expect={a}")
    sys.exit(1)
print("mismatch but no differing element found")
sys.exit(1)
PY
}

echo "[4/5] Run testcases under simulator"

shopt -s nullglob
case_dirs=("$TESTDIR"/*)
if (( ${#case_dirs[@]} == 0 )); then
  echo "ERROR: no testcases under: $TESTDIR" >&2
  exit 2
fi

TOTAL=0
for case_dir in "${case_dirs[@]}"; do
  [[ -d "$case_dir" ]] || continue
  name="$(basename "$case_dir")"
  v1="$case_dir/v1.bin"
  v2_init="$case_dir/v2_init.bin"
  expect="$case_dir/expect_v2.bin"

  if [[ ! -f "$v1" ]]; then
    echo "ERROR: missing $v1" >&2
    exit 2
  fi

  v2_init_arg="-"
  if [[ -f "$v2_init" ]]; then
    v2_init_arg="$v2_init"
  fi

  expect_arg="$expect"
  if [[ ! -f "$expect" ]]; then
    expect_arg="$PWD/.tmp/expect_${name}.bin"
    .tmp/run_cpu_case "$v1" "$v2_init_arg" "$expect_arg"
  fi

  out="$PWD/.tmp/out_${name}.bin"
  .tmp/run_310b_case "$DEV_O" "$KERNEL_SYM" "$DEVICE_ID" "$v1" "$v2_init_arg" "$out"

  ((TOTAL++))
  if cmp -s "$out" "$expect_arg"; then
    echo "PASS [$name]"
  else
    echo "FAIL [$name]" >&2
    diff_i32 "$expect_arg" "$out" >&2 || true
    exit 1
  fi
done

echo "[5/5] ALL PASS ($TOTAL cases)"
